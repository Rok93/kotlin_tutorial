package chap08

/**
 * 코틀린의 함수도 매우 간편하다. 동적 타입을 지원하며 여러 요소들을 생략할 수 있어 형태를 간결하게 만들 수도 있다.
 * 기본 함수의 골격은 아래의 코드와 같다.
 *
 * fun 함수명(변수명: 타입, 변수명: 타입 ....): 반환형 {
 *     내용...
 *     return 반환값
 * }
 */


/**
 * 만약 반환이 없는 함수라면 아래의 코드와 같이 반환형태에 Unit이라고 쓴다. 이는 자바에서 메서드를 선언할 때
 * 반환타입을 void로 사용하는 것과 같은 뜻이다
 */
fun printSum(a: Int, b: Int) {
    println(a + b)
}

/**
 * 예를 들어 Int형 인자 2개를 받아 합을 돌려주는 함수를 정의해보자면 아래와 같다. 이번 장에서는 이 더하기 함수를 예를 들어 설명할 것이다.
 */
fun sum1(a: Int, b: Int): Int {
    return a + b
}

/**
 * 또한 인자에는 각 디폴트 값을 부여할 수 있다. 아래의 코드와 같이 함수를 호출할 때 해당 인자를 넘겨주지 않는다면,
 * 디폴트 값이 부여되어 들어간다.
 */
fun sum2(a: Int, b: Int = 5): Int {
    return a + b
}

fun main(args: Array<String>) {
    val result = sum2(10)
    println(result)
}

/**
 * 눈치 빠른 사람은 눈치를 챘겠지만 main함수에는 변환형을 명시해주지 않았었다.
 * 즉 코틀린에서는 반환하는 값이 없으면 반환형을 생략할 수 있다.
 */
fun printSum2(a: Int, b: Int): Unit {
    println(a + b)
}

/**
 * 또한 코틀린의 함수선언에는 강력한 문법이 있는데, 함수의 내용이 단일 행일 경우는 아래와 같이 매우 간단하게 선언할 수 있다.
 */
fun sum3(a: Int, b: Int) = a + b

/**
 * 위의 코드에서는 분명 반환 값이 있는데 리턴타입을 생략해버렸다. 코드가 한 줄이기에 코드의 내용을 보고 리턴 타입을 유추할 수 있기 때문이다.
 * 하지만 안타깝게 여기서도 인자의 자료형을 생략할 수 없다. 이유는 인자의 타입마저 생략해버리면 인자가 어떤 형태로 넘어올지 유추할 수 없기 때문이다.
 *
 * 인간의 관점에서 위의 코드의 더하기 함수를 보자. 우리는 매개변수 a와 b가 정수라는 것을 알기에 두 값을 더한 결과가 정수로 리턴될 것이라는 것을 유추할 수 있다.
 *
 * 하지만 a와 b의 타입을 생략한다면 a와 b에 String이 들어갈지, Int가 들어갈지, 혹은 다른 타입이 들어갈지 모르기 때문에 인자의 타입은 커녕 반환타입마저도
 * 유추할 수 없게 된다. 아래의 코드를 유추해보자. 쉽지 않을 것이다.
 */
//fun sum(a, b) = a + b // 이 코드는 컴파일 오류를 일으킨다.

/**
 * 코틀린의 장점 중 하나는 에러에 대한 안정성에 있다. 파이썬 같은 다른 동적타입언어는 함수에서 인자의 타입을 생략하지만
 * 그 타입에 정의되지 않은 속성을 사용하려면 에러를 발생시키고, 에러가 발생한다면 여러분도 알다시피 프로그램의 구동이 중지된다.
 * 코틀린은 이러한 것을 원하지 않는 것이다. 코틀린의 묘미 중 하나는 최소의 제약으로 최대의 유연성에 안정성까지 취할 수 있다는 점에 있지 않을까 싶다.
 **/


